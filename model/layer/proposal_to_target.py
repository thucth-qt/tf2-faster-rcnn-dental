import numpy as np
from config.config import cfg
from model.utils.bbox_transform import bbox_iou, bbox2delta


def proposal_to_target(rois, gt_boxes, labels):
    """
    Sample a portion of rois for training and assign ground truth boxes to given rois.
    (no backprop through this process)
    
    Notation:
    - N: number of rois generated by proposal layer
    - K: number of ground truth objects in image
    - S: number of sampled rois
    
    Inputs:
    - rois: tf.float, (x_min, y_min, x_max, y_max), shape=(N, 4)
    - gt_boxes: tf.float, (x_min, y_min, x_max, y_max), shape=(K, 4)
    - labels: tf.int, ground truth labels(cls), shape=(K, 1), since these are the gt labels,
              there won't be 0s(background).
    
    Outputs:
    - sample_rois: np.float, sampled rois with foreground and background rois, shape=(S, 4)
    - roi_bbox_targets: np.float, bbox regression targets, shape=(S, 4)
    - roi_gt_labels: np.int, sampled roi labels, shape=(S, 1)
    """
    
    if cfg.proposal_sample_use_gt:
        rois = np.concatenate((rois, gt_boxes), axis=0)
    rois = np.ascontiguousarray(rois, dtype=np.float32)
    gt_boxes = np.ascontiguousarray(gt_boxes, dtype=np.float32)
    labels = np.ascontiguousarray(labels, dtype=np.int32)
    
    # ious shape=(N, K)
    ious = bbox_iou(rois, gt_boxes)
    
    # find out which gt_box to be assigned to each roi
    gt_assignment = np.argmax(ious, axis=1) # (N, )
    roi_gt_labels = labels[gt_assignment] # (N, )
    max_iou = np.max(ious, axis=1) # (N, )
    # print(np.concatenate(([gt_assignment],[roi_gt_labels], [max_iou]), axis=0).T[:100])
    fg_inds = np.where(max_iou >= cfg.fg_thresh)[0]
    bg_inds = np.where((max_iou >= cfg.bg_thresh_lo) &
                       (max_iou < cfg.bg_thresh_hi))[0]

    # clamp the number of fg rois and bg rois
    fg_rois_per_img = int(min(cfg.max_fg_rois, fg_inds.shape[0]))
    bg_rois_per_img = int(cfg.num_sample_rois - fg_rois_per_img)
    
    # Sample the indices
    if fg_inds.size > 0:
        fg_inds = np.random.choice(fg_inds, size=fg_rois_per_img, replace=False)

    if bg_inds.size > 0:
        if_replace = bg_inds.shape[0] < bg_rois_per_img
        bg_inds = np.random.choice(bg_inds, size=bg_rois_per_img, replace=if_replace)
    # The sampling method implemented here, make sure even if the fg_inds larger  
    # than max_fg_rois(128*0.25), the keep_inds.size will still be num_sample_rois(128)
    keep_inds = np.append(fg_inds, bg_inds)
    roi_gt_labels = roi_gt_labels[keep_inds]
    roi_gt_labels[fg_rois_per_img:] = 0
    roi_gt_labels = np.reshape(roi_gt_labels, (-1, 1))
    sample_rois = rois[keep_inds]
    
    roi_bbox_targets = bbox2delta(sample_rois, gt_boxes[gt_assignment[keep_inds]])
    
    # normalize roi_bbox_targets
    if cfg.norm_bbox:
        roi_bbox_targets = (roi_bbox_targets - cfg.norm_mean) / cfg.norm_std
    
    return sample_rois, roi_bbox_targets, roi_gt_labels
    